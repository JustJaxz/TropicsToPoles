---
title: 'Metbarcoding pipeline'
subtitle: 'Microalgae diversity & community composition'
author: 
- "Stuart, J., Pearman, J.K."
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
---


## Setup {.tabset .tabset-fade}
### Installing & Loading Packages
#### Installing & Loading Packages

In this section, we're setting up the R environment for our analysis.
We are installing or loading the necessary R packages.
It is essential to make sure that these packages are available in your R environment 
before proceeding with the analysis. If you already have these packages installed, 
you can skip the installation process, which can be time-consuming.

The packages here are required for the entire analysis pipeline. a brief description of each follows: 
  
* `devtools` package, which is useful for installing packages from GitHub. More info [here](https://www.r-project.org/nosvn/pandoc/devtools.html)
* `ranacapa` package offers a set of tools and functions for processing and analyzing eDNA data, specifically for identifying and characterizing biodiversity in various ecosystems. More info [here](https://github.com/gauravsk/ranacapa)  
* `phyloseq` package provides classes and functions for microbiome/metabarcoding data. More info [here](https://github.com/joey711/phyloseq)  
* `ggplot2` is a package for creating data visualizations. More info [here](https://ggplot2.tidyverse.org/)  
* `vegan` provides functions for community ecology analysis. More info [here](https://rdrr.io/cran/vegan/man/vegan-package.html)  
* `dplyr` is a package for data manipulation. More info [here](https://nyu-cdsc.github.io/learningr/assets/data-transformation.pdf)  
* `ggVenDiagram` is required for creating Venn diagrams using ggplot2. More info [here](https://r-charts.com/part-whole/ggvenndiagram/)  
* `ggrepel` package in enhances ggplot2 visualizations by automatically adjusting the position of text labels and annotations to prevent overlap, making complex and crowded plots more readable and visually appealing.

```{r, LoadPackages}
#install.packages("devtools")
library(devtools)
#devtools::install_github("gauravsk/ranacapa")
#if(!requireNamespace("BiocManager")){
#  install.packages("BiocManager")
#}
#BiocManager::install("phyloseq")
#install.packages("ggplot2")
#install.packages("vegan")
#install.packages("dplyr")
#install.packages("ggVennDiagram")
#install.packages("ggrepel")
#install.packages("ggpubr")
#install.packages("ape")

library(ape)
library(ggpubr)
library(phyloseq)
library(ranacapa)
library(ggplot2)
library(vegan)
library(dplyr)
library(ggVennDiagram)
#library(ggrepel)
```

### Define Functions
#### Define Functions

__Update taxa NAs__  
This function takes a data frame e.g. `taxa.df` as input then

1.  Convert to Character: In the beginning, the function ensures that all values in the data frame are of character data type by looping through each column and converting its values to character.\
2.  Replace NAs: The function then looks for missing values (NAs) within the data frame. When it encounters an NA at a specific position in the data frame, it identifies which taxonomic level that column corresponds to. This is determined by the index, with columns 1 to 9 representing Domain, Supergroup, Division, Subdivision, Class, Order, Family, Genus, and Species, respectively.\
3.  Create "Unclassified" Value: For each missing value, the function generates a new value to replace the NA. This new value is constructed as "Unclassified\_" followed by the corresponding taxonomic level name. For example, if a missing value is in the Division column, it would be replaced with "Unclassified_Division."\
4.  Assign the New Value: The function then assigns this newly generated "Unclassified" value to the column containing the missing value and all subsequent columns of that row, ensuring that all lower taxonomic levels are also marked as "Unclassified" for that specific taxonomic group.

```{r func.update_taxa_na}
update_taxa_na <- function(taxa_df) {
  for (i in 1:9) {
    taxa_df[, i] <- as.character(taxa_df[, i])
  }
  
  taxa_df[is.na(taxa_df)] <- ""  # Replace any missing values with empty strings

  for (i in 1:nrow(taxa_df)) {
    if (taxa_df[i, 2] == "") {
      kingdom <- paste("Unclassified_Domain_", taxa_df[i, 1], sep = "")
      taxa_df[i, 2:9] <- kingdom
    } else if (taxa_df[i, 3] == "") {
      supergroup <- paste("Unclassified_Supergroup_", taxa_df[i, 2], sep = "")
      taxa_df[i, 3:9] <- supergroup
    } else if (taxa_df[i, 4] == "") {
      division <- paste("Unclassified_Division_", taxa_df[i, 3], sep = "")
      taxa_df[i, 4:9] <- division
    } else if (taxa_df[i, 5] == "") {
      subdivision <- paste("Unclassified_SubDivision_", taxa_df[i, 4], sep = "")
      taxa_df[i, 5:9] <- subdivision
    } else if (taxa_df[i, 6] == "") {
      class <- paste("Unclassified_Class_", taxa_df[i, 5], sep = "")
      taxa_df[i, 6:9] <- class
    } else if (taxa_df[i, 7] == "") {
      order <- paste("Unclassified_Order_", taxa_df[i, 6], sep = "")
      taxa_df[i, 7:9] <- order
    } else if (taxa_df[i, 8] == "") {
      family <- paste("Unclassified_Family_", taxa_df[i, 7], sep = "")
      taxa_df[i, 8:9] <- family
    } else if (taxa_df[i, 9] == "") {
      taxa_df$R9[i] <- paste("Unclassified_Genus_", taxa_df$R8[i], sep = "_")
    }
  }
  
  return(taxa_df)
}

```

Usage: Assuming you have a data frame called taxa.df `updated_taxa_df <- update_taxa_na(taxa.df)`

__Sequence Summary Stats__  
The `calculate_summary` function takes a dataset, a region identifier, and a community identifier as input and calculates several summary statistics for the dataset. These statistics include the total number of ASVs (Amplicon Sequence Variants) in the dataset, the minimum and maximum ASV counts across sites, the mean ASV count, and the standard error of the mean. It then organizes this information into a data frame with site-specific details and returns the data frame, providing a concise summary of the dataset's characteristics within the specified region and community.

```{r func.summaryStats}
std.error <- function(x) sd(x)/sqrt(length(x))

calculate_summary <- function(data, region, community) {
  total_ASVs <- sum(sample_sums(data))
  min_val <- min(sample_sums(data))
  max_val <- max(sample_sums(data))
  std_error <- std.error(sample_sums(data))
  mean_val <- mean(sample_sums(data))
  
  df <- data.frame(Site = unique(sample_data(data)$siteID),
                   Region = region,
                   Total_ASVs = total_ASVs,
                   Minimum = min_val,
                   Maximum = max_val,
                   Mean = mean_val,
                   Std_Error = std_error,
                   Community = community
  )
  
  return(df)
}

```
  
__ASV percentages per site__  
The function calculate_grouped_percentages performs the following tasks:  
  
1. Subset Data: It selects data corresponding to a specified sample label within a `phyloseq` dataset.  
2. Calculate Percentages: It computes the percentages of abundance for each taxonomic class within the selected sample, normalized to sum up to 100%.  
3. Grouping and Summarizing: It groups the taxonomic classes into defined categories (e.g., dinoflagellates, diatoms) as per the provided class groupings and summarizes the percentages within these categories.  
4. Return Results: Finally, it returns a dataframe containing the percentages of taxonomic class groupings for the specified sample label in the `phyloseq` dataset.  
```{r func.asvPerc}

class_groupings <- list(
  dinoflagellates = c("Dinophyceae"),
  diatoms = c("Bacillariophyceae", "Coscinodiscophyceae", "Mediophyceae"),
  chlorophytes = c("Chlorodendrophyceae", "Chlorophyceae", "Chloropicophyceae", "Mamiellophyceae", "Nephroselmidophyceae", "Pedinophyceae", "Trebouxiophyceae", "Pedinophyceae", "Picocystophyceae", "Prasinophyceae", "Pyramimonadophyceae"),
  haptophytes = c("Coccolithophyceae", "Prymnesiophyceae", "Pavlovophyceae", "Rappephyceae"),
  other = c("Bolidophyceae", "Chrysophyceae", "Dictyochophyceae", "Eustigmatophyceae", "Pinguiophyceae", "Pelagophyceae", "Raphidophyceae", "Synchromophyceae", "Euglenida")
)

calculate_grouped_percentages <- function(phy_data, sample_label, class_groupings) {
  # Subset data for the specified sample label
  sample_data <- subset(phy_data, Sample == sample_label)
  
  # Calculate percentages for the specified sample label
  sample_percentages <- sample_data %>%
    group_by(Class) %>%
    summarise(Percentage = sum(Abundance)) %>%
    mutate(Percentage = Percentage / sum(Percentage) * 100)  # Calculate percentage within each class
  
  # Merge the percentages back into the sample data
  sample_data <- left_join(sample_data, sample_percentages, by = "Class")
  
  # Group percentages and rename to match object names
  grouped_percentages <- sample_data %>%
    mutate(Class_Group = case_when(
      Class %in% class_groupings$dinoflagellates ~ "dinoflagellates",
      Class %in% class_groupings$diatoms ~ "diatoms",
      Class %in% class_groupings$chlorophytes ~ "chlorophytes",
      Class %in% class_groupings$haptophytes ~ "haptophytes",
      Class %in% class_groupings$other ~ "other",
      TRUE ~ "unclassified"
    )) %>%
    group_by(Class_Group) %>%
    summarise(Percentage = sum(Percentage)) %>%
    rename(Class = Class_Group) %>%
    mutate(site = sample_label)
  
  return(grouped_percentages)
}
```

### Data Prep
#### Data Prep

Set working directory.
If your files are on 'OneDrive' it is worth making a folder locally to stop links breaking. Do remember to back up your files to 'OneDrive' afterwards though!

```{r setwd}
setwd("C:/Users/user1/Documents/R")
```

Start by loading data and sub-setting for this chapter.
There is sequence data for both the 18s V4 and V9 gene regions. This data has already been run through the DADA2 pipeline and undergone chimera removal, trimming, cleaning etc. It is now ready for general analysis.  
Here we will be using the V9 for all the diversity indices and community composition analysis, and the V4 and V9 to look at taxonomic diversity via dendrogram.  
  
This line of code loads data from an RDS file for the 18S V9 metabarcoding data and assigns the name `clean.v9`.

```{r loadData}
# Load in data
V9 <- readRDS("C:/Users/user1/Documents/R/v9.cleaned2.rds")
#V4 <- readRDS("C:/Users/user1/Documents/R/v4.cleaned2.rds")
```

The following code filters the taxa in the `V9` object and updates the `V9` variable. It removes taxa with a total sum of values less than or equal to 0, effectively eliminating taxa with minimal or no abundance in the data set.

```{r clean}
V9 <- phyloseq::filter_taxa(V9, function(x) sum(x) > 0, TRUE)
#V4 <- phyloseq::filter_taxa(V4, function(x) sum(x) > 0, TRUE)
```

Here, the code subsets the data to include only samples categorized as "water" based on metadata, these are all the vertical plankton net tow samples. It also extracts the taxonomic data into a data frame.

```{r waterSubset}
# Subset to only water samples using metadata
taxa.df <- data.frame(phyloseq::tax_table(V9))
waterSamples <- phyloseq::subset_samples(V9, ecosystem == "water")

#V4.taxa.df <- data.frame(tax_table(V4))
#V4.waterSamples <- subset_samples(V4, ecosystem == "water")
```

This section of code removes samples associated with historic sites ("H1" through "H7") from the `waterSamples` data, as we are only looking at data from 2021 - 2022 in this sample set. If you define the `waterSamples_filtered` you can start most analysis without having to do the previous
```{r HistoricRemoval}
# Removing the historic Antarctic samples
sites_to_remove <- c("H1", "H2", "H3", "H4", "H5", "H6", "H7")

waterSamples_filtered <- phyloseq::subset_samples(waterSamples, !siteID %in% sites_to_remove)
saveRDS(waterSamples_filtered, file = "Chp3_phd_waterSamples.rds")

#V4.waterSamples_filtered <- phyloseq::subset_samples(V4.waterSamples, !siteID %in% sites_to_remove)
```
    
  ***  
  
__Region & Site details__  

```{r siteDetails}
# Ecoregions
ecoregion_categories <- c("Tropical", "Sub-tropical", "Temperate", "Sub-polar", "Polar")
# Site Labels
sitelabels <- c("N1", "N2", "N3", "N4", "N5", "N6", "T1", "T2", "T3", "P5", "P6", "P7", "P8", "P9", "P10", "P11", "C1", "C2", "C3" )
#Site order

# Define the corresponding sites for each ecoregion
tropical_sites <- c("T1", "T2", "T3")
subtropical_sites <- c("N4", "N5", "N6")
temperate_sites <- c("N1", "N2", "N3")
subpolar_sites <- c("C1", "C2", "C3")
polar_sites <- c("P5", "P6", "P7", "P8", "P9", "P10", "P11")
```
  
  ***  
  
__Taxonomy details__  
  
```{r taxoDivisions}
# Taxonomy Divisions for tax_tables
taxo.divisions <- c("Domain", "Supergroup", "Division", "Sub-division", "Class", "Order", "Family", "Genus", "Species")

# EMC Taxonomic groups (to class level)
emc.classes <- c("Dinophyceae", "Bacillariophyceae", "Coscinodiscophyceae", "Mediophyceae", "Chlorodendrophyceae", "Chlorophyceae", "Chloropicophyceae", "Mamiellophyceae", "Nephroselmidophyceae", "Pedinophyceae", "Trebouxiophyceae", "Pedinophyceae", "Picocystophyceae", "Prasinophyceae", "Pyramimonadophyceae", "Coccolithophyceae", "Prymnesiophyceae", "Pavlovophyceae", "Rappephyceae", "Bolidophyceae", "Chrysophyceae", "Dictyochophyceae", "Eustigmatophyceae", "Pinguiophyceae", "Pelagophyceae", "Raphidophyceae", "Synchromophyceae", "Euglenida")

# EMC Taxonomic subsets
dinoflagellates <- c("Dinophyceae")
diatoms <- c("Bacillariophyceae", "Coscinodiscophyceae", "Mediophyceae")
chlorophytes <- c("Chlorodendrophyceae", "Chlorophyceae", "Chloropicophyceae", "Mamiellophyceae", "Nephroselmidophyceae", "Pedinophyceae", "Trebouxiophyceae", "Pedinophyceae", "Picocystophyceae", "Prasinophyceae", "Pyramimonadophyceae")
haptophytes <- c("Coccolithophyceae", "Prymnesiophyceae", "Pavlovophyceae", "Rappephyceae")
other <- c("Bolidophyceae", "Chrysophyceae", "Dictyochophyceae", "Eustigmatophyceae", "Pinguiophyceae", "Pelagophyceae", "Raphidophyceae", "Synchromophyceae", "Euglenida")
```
    
***  
### Colour Schemes
#### Colour Schemes

Define colour schemes here. These are used throughout the analysis.  
*This code defines a function `print_pal` that takes a vector x of colors as input.  
*The function sets up a graphical display to show the colors in the input vector `x`.  
```{r, palletFunction}
print_pal <- function(x, ...) {
  n <- length(x)
  old <- par(mar = c(0.5, 0.5, 0.5, 0.5))
  on.exit(par(old))

  image(1:n, 1, as.matrix(1:n), col = x,
        ylab = "", xaxt = "n", yaxt = "n", bty = "n", ylim = c(0, 1))
}

```
  
__Ecoregion Colours__  

This section defines color schemes specific to ecoregions.  
In this research we are looking at the EMCs across five ecoregions: Tropical, subtropical, temperate, sub-polar and polar. The idea is to  use these colours throughout for consistency in the visual language.  
* `ecoregion_cols` is a vector containing color codes for different ecoregions.  
* `cols.eco` is created as a color ramp palette based on the ecoregion colors.  
* The `print_pal` function is used to display the ecoregion colors.  
  
```{r, EcoCols}

# Ecoregion colours
ecoregion_cols <- c("tropical" = "#f0e097", "sub-tropical" = "#cfe5b2", "temperate" = "#88b945", "sub.polar" = "#a9dac9", "polar" = "#89b7e5")
cols.eco <- colorRampPalette(ecoregion_cols)
print_pal(ecoregion_cols)
```
  
  
__Venn Colours__  

This section defines a color scheme for Venn diagrams. In this study a Venn diagram is used to show high to low amplicon sequence variant (ASV) crossover between ecoregions. Therefore using a split complementary colour scheme with the ability to make a 'hot to cold' or 'high to low' feel is important.  
  
* `venn_cols` is a vector containing colors for Venn diagrams.  
* `cols.venn` is created as a color ramp palette based on the Venn colors. This means you can use it as a gradient colour scheme, and define how many values are required.  
* `vennLine_cols` contains line colors for the Venn diagram.  
* `The print_pal` function is used to display the Venn diagram colors.  
  
```{r, vennCols}
# Venn Diagram colour scheme
venn_cols <- c( "#efffff","#8dd2f9", "#4b8cca", "#ffcb27",  "#f48521", "#bc3635") 
cols.venn <- colorRampPalette(venn_cols) # this makes the colourscheme a function that can be used as with continuous data sets
vennLine_cols <- c("#e1f6ff", "#e1f6ff", "#e1f6ff", "#e1f6ff", "#e1f6ff") # this must match the number of elements in your list

print_pal(venn_cols)
```
  
__General Colours__  
  
This is one of the Cawthron colour schemes. It can be used to create colour ramps or just used as a normal colour pallete. When there is no other specificly assigned palette use this one.  
  
* caw.adj is a vector containing general colors.  
* cols.adj is created as a color ramp palette based on the general colors.  
* The print_pal function is used to display the general colors.


```{r, cawCols}
caw.adj <- c("#FBD872", "#ffe1a7", "#f48521", "#968CC3", "#e8b5d4", "#7AC4D3", "#4b8cca", "#00549e", "#4aa890", "#2f725e", "#4A773C", "#004f52"  )
cols.adj <- colorRampPalette(caw.adj)

print_pal(caw.adj)
```

__EMC group Colours__  

This section defines color schemes for different EMC (Eukaryotic Microbial Community) groups. There are essentially six base colours that are then applied to the taxonomic-functional 'bins' used in this study. They include:  
  
* Dinoflagellates (Classes: Dinophyceae)  
* Pennate Diatoms (Classes: Bacillariophyceae)  
* Radial Centric Diatoms (Classes: Coscinodiscophyceae)  
* Polar Centric Diatoms (Classess: Mediophyceae)  
  
```{r, emcCols}
emc_cols <- c(Bacillariophyceae = "#f16a58", 
              Coscinodiscophyceae = "#faddb4", 
              Mediophyceae = "#fab768",
              Dinophyceae  = "#70b6cf",
              # Chlorophytes
              Chlorodendrophyceae = "#cfe3e0", Chlorophyceae = "#cfe3e0", Chloropicophyceae = "#cfe3e0", Mamiellophyceae = "#cfe3e0", Nephroselmidophyceae =  "#cfe3e0", Pedinophyceae = "#cfe3e0", Trebouxiophyceae = "#cfe3e0", Pedinophyceae = "#cfe3e0", Picocystophyceae = "#cfe3e0", Prasinophyceae = "#cfe3e0", Pyramimonadophyceae = "#cfe3e0",
              # Haptophytes
              Coccolithophyceae = "#9eb0cf", Prymnesiophyceae = "#9eb0cf", Pavlovophyceae = "#9eb0cf", Rappephyceae = "#9eb0cf",
              #other
              Bolidophyceae = "#574e90", Chrysophyceae = "#574e90", Dictyochophyceae = "#574e90", Eustigmatophyceae = "#574e90", Pinguiophyceae = "#574e90", Pelagophyceae = "#574e90", Raphidophyceae = "#574e90", Synchromophyceae = "#574e90", Euglenida = "#574e90")

emc_cols.grp <- c(Dinoflagellates  = "#70b6cf", Penate.Diatoms  = "#f16a58", Radial.Centric.Diatoms = "#faddb4", Polar.Centric.Diatoms = "#fab768", Chlorophytes  = "#cfe3e0", Haptophytes = "#9eb0cf", Other = "#574e90")

print_pal(emc_cols.grp)

```

__Diatom Order Colours__  

These are used for the community composition plots, and divided tonally by pennate, radial centric and polar centric diatoms.  
  
```{r diaCols}
dia.order.cols <-c(Bacillariales = "#39103a",  Cymbellales  = "#511851", Fragilariales = "#543a7a", Licmophorales = "#6b61a0",
                   Naviculales = "#988cc2", Plagiogrammales= "#8779B9", Rhabdonematales = "#9073b3", Rhaphoneidales = "#cca1d6", 
                   Rhopalodiales  =  "#b484bf", Surirellales = "#9164ab", Unclassified_Class_Bacillariophyceae = "#d9bde0", #Pennate
                  
                   Corethrales = "#ffebc0", Coscinodiscales = "#ffe09c", Melosirales = "#ffc176", Paraliales = "#F5A83D", 
                  Rhizosoleniales  = "#F39716", Stellarimales = "#F9CB8B", Triceratiales = "#FBDCB1", Unclassified_Class_Coscinodiscophyceae = "#ffa750", 
                  
                  Anaulales = "#FFB199", Ardissoneales  = "#FF430A", Biddulphiales  = "#FF7247", Chaetocerotales  = "#ff8a66", 
                  Cymatosirales  = "#E03400", Eupodiscales  = "#ed6453", Hemiaulales  = "#c73e34", Lithodesmiales  = "#B2372E", 
                  Probosciales = "#A2322A", Thalassiosirales = "#822821", Unclassified_Class_Mediophyceae = "#330913" #polar.cent
)
print_pal(dia.order.cols)
```

__Dinoflagellate Order Colours__  

These are also used for the community composition plots for dinoflagellates.   
  
```{r dinoCols}
dino_cols <- c("#11616A",  "#96E5EE", "#1DA1AF", "#00549E", "#ADD9FF", "#0065BD", "#203075", "#A1BBE3")
cols.dia <- colorRampPalette(dino_cols)

print_pal(dino_cols)
```
### {-}  
***  
  

## Analysis
### Rarefaction Curve
__Data Wrangling__  
This part of the code prepares data for creating a rarefaction curve plot. It sets labels for different sampling points and merges the samples from each site.
``` {r SiteLabels}
# Merge the filtered samples by siteID
mergeWater.v9 <- phyloseq::merge_samples(waterSamples_filtered, "siteID")
#mergeWater.V4 <- phyloseq::merge_samples(V4.waterSamples_filtered, "siteID")

```

__Subset to EM Taxa__

Here, we subset the data to include only Eukaryotic Microalgae taxa based on the R5 or class categories, where R1 = Domain, R2 = Supergroup, R3 = Division, R4 = Phylum, R5 = Class, R6 = Order, R7 = Family, R8 = Genus, R9 = Species.  
  
For this research the Eukaryotic microalgae taxa are binned into high level taxonomic-functional groups that include; Dinoflagellates, pennate diatoms, radial centric diatoms, polar centric diatoms, haptophytes, chlorophytes and 'other'.   

These divisions are used consistently throughout the analysis. 

```{r rare_SubsetEMC}
# Convert to data frame
taxa.df <- data.frame(phyloseq::tax_table(mergeWater.v9)) 
#Subset to emc classes (R5)
rare.waterSamples <- phyloseq::subset_taxa(mergeWater.v9, R5 %in% emc.classes)

# update dataframe
taxa.df <- data.frame(phyloseq::tax_table(rare.waterSamples))

# removes all `NA's` in taxonomy.
tax.clean <- data.frame(phyloseq::tax_table(rare.waterSamples)) 

```

__EMC Sequence data info__  
Here we want to find out what proportion of the raw reads is made up by each ecoregion.
First the samples are merged based on their ecoregion, then subset to the EMC.

```{r rare_DataSummary}

ecoRegionWater.v9 <- phyloseq::merge_samples(waterSamples_filtered, "ecoregion")
#ecoRegionWater.V4 <- phyloseq::merge_samples(V4.waterSamples_filtered, "ecoregion")

#Subset to emc classes (R5)
V9.waterSamples_emc <- phyloseq::subset_taxa(ecoRegionWater.v9, R5 %in% emc.classes)
#V4.waterSamples_emc <- phyloseq::subset_taxa(ecoRegionWater.V4, R5 %in% emc.classes)

```

```{r rare_CalculateSummary}
#v4.emc_summary <- calculate_summary(V4.waterSamples_emc, "v4", "Emc")
v9.emc_summary <- calculate_summary(V9.waterSamples_emc, "v4", "Emc")

sample_sums(V9.waterSamples_emc)
#sample_sums(V4.waterSamples_emc)

```


__Plot rarefaction curve__  
This code creates a rarefaction curve plot for the Chp3.waterSamples data, providing insights into the data set's richness and diversity. The plot is created with the minimal theme.  
This will most likely end up in the supplementary materials, but is good to assess what level you should rarefy your samples to for further analysis.

```{r, PlotRareCurve}
rareCurve_plot <- ggrare(rare.waterSamples, step = 2000, label = sitelabels) +
  labs(title = "SSU v9 region") +
  theme_minimal()

#view sample metadata associated with phyloseq file 
rareCurve_plot

```
  
***  

### Diversity Analysis {.tabset .tabset-fade} 
__What is diversity analysis?__  
Here we are looking at alpha and beta diversity and unique ASVS of the sampled EMCs.    
* Alpha diversity measures species richness within a specific microalgae community, representing the diversity at a local scale. It assesses the number of unique taxa and their abundance.  
* Beta diversity, on the other hand, evaluates the variation in species composition between different microalgae communities. It measures the turnover or differentiation of species across habitats, providing insights into community dissimilarity.  
  
With this microalgae metabarcoding data, alpha diversity indicates how many and how evenly distributed species are within a sample, while beta diversity highlights differences in microalgae composition between distinct environments or conditions. Both analyses offer valuable insights into the ecological patterns and dynamics of microalgae communities.  
  
#### Alpha Diversity
__Alpha diversity Data Prep__  
This code block assigns a specific order to the `ecoregion` factor levels in the sample data of the `alpha.waterSamp_pru` object. The factor levels are reordered to match the specified sequence: "tropical," "sub-tropical," "temperate," "sub-polar," and "polar." This will affect the order in which the ecoregions are displayed in subsequent plots
```{r, Alpha_sampleData}

#Subset to emc classes (R5)
alpha.waterSamples <- phyloseq::subset_taxa(waterSamples_filtered, R5 %in% emc.classes)

# Pruning OTUs that are not present in any of the samples
alpha.waterSamp_pru <- phyloseq::prune_taxa(taxa_sums(alpha.waterSamples) > 0, alpha.waterSamples)

tax.df <- data.frame(phyloseq::tax_table(alpha.waterSamp_pru))

phyloseq::sample_data(alpha.waterSamp_pru)$ecoregion <- factor(phyloseq::sample_data(alpha.waterSamp_pru)$ecoregion, levels = c("tropical", "sub-tropical","temperate", "sub.polar", "polar"))
```

In this code block, rarefaction is applied to the `alpha.waterSamp_pru` object. It trims the samples to a minimum sum of 19,000 reads based on the results of a rarefaction curve. The `alpha.waterSamp_pru.rare` variable stores the rarefied samples. The `sample_sums` function is used to check the sample sums after rarefaction.

```{r, Rarefy}
#rarefy
waterSamples_trim <- phyloseq::prune_samples(phyloseq::sample_sums(alpha.waterSamp_pru) >= 11000, alpha.waterSamp_pru) # change number based on the results of your rarefaction curve.
alpha.waterSamp_pru.rare <- phyloseq::rarefy_even_depth(waterSamples_trim, min(phyloseq::sample_sums(waterSamples_trim)), replace=F) 

phyloseq::sample_sums(alpha.waterSamp_pru.rare)
```

__Alpha Indicies Plot__  
This code block creates a richness plot (alpha diversity) for the rarefied `alpha.waterSamp_pru.rare` object. It displays Chao1, Shannon, and Inverse Simpson richness measures. Custom ecoregion colors are specified, and the site ID order is changed according to the earlier factor reordering. The plot's appearance is adjusted using theme settings, including grid line width and point size.

```{r, AlphaPlot, fig.cap="Analysis of alpha diversity indices of Eukaryotic Microalgae across five ecoregions calculated from rarefied ASV data including Chao1, Shannon and Inverse Simpson indexes for the 18s V9 region. (P value adjustment method: BH)"}
# Plotting Alpha with custom ecoregion colors and changed site ID order

theme_set(theme_minimal())

a_my_comparisons <- list( c("Tropical", "Sub-tropical"), c("Tropical", "Temperate"), c("Tropical", "Sub-polar"), c("Tropical", "Polar")#, 
                          #c("Sub-tropical", "Temperate"), c("Sub-tropical", "Sub-polar"), c("Sub-tropical", "Polar"),
                          #c("Temperate", "Sub-polar"), c("Temperate", "Polar"),
                          #c("Sub-polar", "Polar")
                          )
symnum.args = list(cutpoints = c(0, 0.0001, 0.001, 0.01, 0.05, 1), symbols = c("****", "***", "**", "*", "ns"))

alpha_plot <- plot_richness(alpha.waterSamp_pru.rare, x = "ecoregion", color = "ecoregion", measures = c("Chao1", "Shannon", "InvSimpson")) +
  geom_boxplot(alpha = 1) +
  scale_color_manual(values = ecoregion_cols) +
  theme(text = element_text(size = 8)) +
  theme(panel.grid.major = element_line(linewidth = 0.5),  # Set major grid line size
        panel.grid.minor = element_line(linewidth = 0.5)) +  # Set minor grid line size
geom_point(size = 0.5, position = position_dodge(width = 0)) +
  geom_errorbar(aes(ymin = after_stat(y), ymax = after_stat(y)), position = "identity", width = 0)# +  # Adjust the value of 'size' to decrease dot size
  #stat_compare_means(label = "p.signif", method = "wilcox.test", ref.group = ".all.")

# creates boxplot
alpha_plot
```

__Tests of Significance__  
In this code block, alpha diversity statistics are calculated and tested using pairwise Wilcoxon tests. It compares richness (Chao1, Shannon, and Inverse Simpson) between different ecoregions. The rich.rare object contains the estimated richness values, and the tests are applied to determine statistical differences between ecoregions. The "BH" method is used for p-value adjustment, and the results are presented as pairwise comparisons.

```{r, wilcoxTests}
rich.rare = estimate_richness(alpha.waterSamp_pru.rare)
pairwise.wilcox.test(rich.rare$Chao1, sample_data(alpha.waterSamp_pru.rare)$ecoregion, p.adjust.method = "BH", paired = FALSE, exact = FALSE)
pairwise.wilcox.test(rich.rare$Shannon, sample_data(alpha.waterSamp_pru.rare)$ecoregion, p.adjust.method = "BH", paired = FALSE, exact = FALSE)
pairwise.wilcox.test(rich.rare$InvSimpson, sample_data(alpha.waterSamp_pru.rare)$ecoregion, p.adjust.method = "BH", paired = FALSE, exact = FALSE)
```

  
#### Beta Diversity
__Beta diversity data Prep__  
This code block performs several data transformation and processing steps to prepare for beta diversity analysis:  
  
* It calculates the percentage abundance of OTUs (Operational Taxonomic Units) in the rarefied `alpha.waterSamp_pru.rare` data using the `transform_sample_counts` function.  
* It filters out OTUs based on a threshold (currently set to >1% abundance) using the `filter_taxa` function, which removes OTUs with an average abundance less than or equal to 0.  
* The filtered data is converted into a data frame format using the `psmelt` function.  
* Bray-Curtis dissimilarity is calculated for the transformed data using the `phyloseq::distance` function with the "jaccard" method for binary data.  
* Principal Coordinates Analysis (PCoA) is performed on the Bray-Curtis dissimilarity matrix using the "NMDS" (Non-Metric Multidimensional Scaling) method.  
* The PCoA vectors are extracted and stored in a data frame.

```{r, BetaPrep}
alpha.waterSamp_pru.rare_perc = transform_sample_counts(alpha.waterSamp_pru.rare, function(OTU) OTU/sum(OTU)*100)

# can change threshold - (> 1) currently at 1 % can go to zero if less abundance
alpha.waterSamp_pru.rare_perc_filtered = filter_taxa(alpha.waterSamp_pru.rare_perc, function(x) mean(x) > 0, TRUE)
alpha.waterSamp_pru.rare_perc_filtered_df <- psmelt(alpha.waterSamp_pru.rare_perc_filtered)

# Calculate Bray-Curtis dissimilarity matrix
alpha.waterSamp_pru.perc_bray <- phyloseq::distance(alpha.waterSamp_pru.rare_perc_filtered, method = "jaccard", binary=T)

# Perform PCoA using Bray-Curtis dissimilarity matrix
alpha.waterSamp_pru.perc_ord <- ordinate(alpha.waterSamp_pru.rare_perc_filtered, method = "NMDS", distance = alpha.waterSamp_pru.perc_bray)

# Extract PCoA vectors and create a data frame
alpha.waterSamp_pru.perc_ord.vectors <- data.frame(alpha.waterSamp_pru.perc_ord$points)

# Assign Ecoregion names to the data frame
alpha.waterSamp_pru.perc_ord.vectors$sampleID <- rownames(alpha.waterSamp_pru.perc_ord.vectors)
sd <- data.frame(sample_data(alpha.waterSamp_pru.rare_perc_filtered))
sd$sampleID <- rownames(sd)
alpha.waterSamp_pru.perc_ord.vectors <- left_join(alpha.waterSamp_pru.perc_ord.vectors, sd, by="sampleID")

```

__Beta Diversity NMDS Plot__  
This code block creates a beta diversity plot using the NMDS results:  
  
*The ggplot function is used to generate the plot, with MDS1 and MDS2 (the first two PCoA dimensions) on the x and y axes, respectively.  
*Points are added to the plot to represent the samples, and their color is determined by the "ecoregion" variable.  
*Custom ecoregion colors are specified with `scale_color_manual`.  
*The plot is styled using the "theme_classic" theme, and ellipses are added using `stat_ellipse`.  
The resulting plot, beta_plot, visualizes the beta diversity among samples in the different ecoregions based on the Bray-Curtis dissimilarity matrix.

```{r, BetaPlot}
# Create the plot
beta_plot <- ggplot(alpha.waterSamp_pru.perc_ord.vectors, aes(x = MDS1, y = MDS2, color = ecoregion)) +
  geom_point(size = 2) +
  scale_color_manual(values = ecoregion_cols) +
  theme_classic() +
  stat_ellipse()

beta_plot
```

__PERMANOVA__  
(Permutational Multivariate Analysis of Variance):  
  
This is a statistical test used to assess the variation in multivariate data sets, especially distance matrices such as beta diversity.
For beta diversity measures, it examines whether the dissimilarity in species composition between samples (e.g., different ecosystems or sites) is statistically significant.  
It tests the null hypothesis that there's no difference in the groups being compared based on the given dissimilarity matrix.  
* Why PERMANOVA: is can be used to Help determine if there are significant differences in species composition between different ecosystems or sites, Examine the influence of categorical variables (like `ecosystems` and `siteID`s) on beta diversity while considering multiple dimensions of community composition.  
* Interpreting Results: The output provides an R-squared (proportion of variance explained), F-statistic, and associated p-value. A low p-value suggests that at least one factor (or interaction) significantly affects the beta diversity.  
* Here `adonis2` is a function from the `vegan` package, used for performing a PERMANOVA analysis on distance matrices. The formula `ice.beta.perc_bray ~ ecosystem * siteID` specifies the model for the PERMANOVA. It examines the association __between__ the Bray-Curtis dissimilarity matrix `ice.beta.perc_bray` and the interaction between `ecosystem` and `siteID` variables.  

```{r BetaPERMANOVA}
# Using vegan's adonis function for PERMANOVA
beta_diversity_model <- adonis2(alpha.waterSamp_pru.perc_bray ~ ecoregion, data = alpha.waterSamp_pru.perc_ord.vectors, permutations = 999)
# View the results
beta_diversity_model

# Perform ANOVA
#anova_result <- summary(anova_model)
#anova_result

```

__POST-HOC TESTS__  
For pairwise comparisons.  
Unfortunately, for PERMANOVA, there isnâ€™t a direct equivalent of a Tukey test for pairwise comparisons as in ANOVA. However, you can conduct pairwise tests or multiple comparisons using other methods like pairwise PERMANOVA or pairwise Bray-Curtis dissimilarity tests. Here's an example using the `pairwise.adonis2` function from the `pairwiseAdonis` package:

```{r BetaPostHoc}
#install.packages("pairwiseAdonis")
#install.packages("devtools")
library(devtools)
install_github("pmartinezarbizu/pairwiseAdonis/pairwiseAdonis")
library(pairwiseAdonis)

unique(as.character(beta_diversity_model[, 1]))
# Assuming beta_diversity_model is the object resulting from adonis2
pairwise_results <- pairwise.adonis2(alpha.waterSamp_pru.perc_bray ~ ecoregion, alpha.waterSamp_pru.perc_ord.vectors, nperm = 999)
# View the results
pairwise_results

#install.packages("RVAideMemoire")
library(RVAideMemoire)

pairwise_results.perm <- pairwise.perm.manova(alpha.waterSamp_pru.perc_bray, alpha.waterSamp_pru.perc_ord.vectors$ecoregion, nperm = 999)
pairwise_results.perm

```

#### Venn Diagram
__Venn diagram data Prep__  
In this code block, subsets of samples are created for each `ecoregion`. Samples are filtered based on their respective ecoregions, and the resulting subsets are assigned to variables such as `tropical`, `subtropical`, `temperate`, `subpolar`, and `polar`. These subsets will be used for further analysis.
```{r, VennEcoregionSubset}
tropical <- subset_samples(waterSamples_filtered, ecoregion == "tropical")
subtropical <- subset_samples(waterSamples_filtered, ecoregion == "sub-tropical")
temperate <- subset_samples(waterSamples_filtered, ecoregion == "temperate")
subpolar <- subset_samples(waterSamples_filtered, ecoregion == "sub.polar")
polar <- subset_samples(waterSamples_filtered, ecoregion == "polar")
```

In this code block, taxonomic data is filtered for each ecoregion subset (tropical, subtropical, etc.). The `subset_taxa` function is used to extract taxa belonging to specific high-level taxonomic classes represented by the `emc.classes` variable. Additionally, taxa with zero abundance are removed using the `prune_taxa` function. The names of the remaining taxa for each ecoregion are stored in variables like `tropical.names`.

```{r, VennFilterTaxa}
tropical.phyto <- subset_taxa(tropical, R5  %in% emc.classes)
subtropical.phyto <- subset_taxa(subtropical, R5  %in% emc.classes)
temperate.phyto <- subset_taxa(temperate, R5  %in% emc.classes)
subpolar.phyto <- subset_taxa(subpolar, R5  %in% emc.classes)
polar.phyto <- subset_taxa(polar, R5  %in% emc.classes)

tropical.phyto <- prune_taxa(taxa_sums(tropical.phyto) > 0, tropical.phyto)
subtropical.phyto <- prune_taxa(taxa_sums(subtropical.phyto) > 0, subtropical.phyto)
temperate.phyto <- prune_taxa(taxa_sums(temperate.phyto) > 0, temperate.phyto)
subpolar.phyto <- prune_taxa(taxa_sums(subpolar.phyto) > 0, subpolar.phyto)
polar.phyto <- prune_taxa(taxa_sums(polar.phyto) > 0, polar.phyto)

tropical.names <- taxa_names(tropical.phyto)
subtropical.names <- taxa_names(subtropical.phyto)
temperate.names <- taxa_names(temperate.phyto)
subpolar.names <- taxa_names(subpolar.phyto)
polar.names <- taxa_names(polar.phyto)

```

__Venn Diagram Plot__  
This code block sets up the Venn diagram plot. It defines a list of data to compare, with each element of the list corresponding to an ecoregion and its associated taxa. The `ggVennDiagram` function creates the base Venn diagram, specifying parameters for the appearance, such as edge size, label options, and category names.
Note color schemes for each figure type are all in the [Setup](##Setup) section of this doc.  
  
1. `venn.v9 <-`: This code initializes a variable `venn.v9` to store the Venn diagram plot generated by the `ggVennDiagram` function.  
2. `ggVennDiagram(otu_list, ...)`: This is where the Venn diagram is created. The `ggVennDiagram` function generates the Venn diagram based on the list of data, `otu_list`, and other specified parameters.  
3. `otu_list`: This list contains data for each ecoregion, where each element (A, B, C, D, E) represents a different ecoregion and its associated taxa.  
4. `edge_size = 3`: It sets the size of the edges of the Venn diagram to 3, determining the width of the lines that separate the regions.  
5. `label_alpha = 0`: This parameter specifies the transparency level for region labels. Setting it to 0 makes the labels completely transparent.  
6. `label = "count"`: This parameter determines what is displayed in the labels of each region. In this case, it shows the count of elements in each region.  
7. `label_size = 3.5`: It sets the font size for the region labels to 3.5 points.  
8. `set_size = 4`: This parameter controls the size of the Venn diagram itself.  
9. `category.names = c("Tropical", "Sub-tropical", "Temperate", "Sub-polar", "Polar")`: It specifies the category names associated with each ecoregion, which will be used to label the regions in the Venn diagram. These names correspond to the ecoregions represented in the `otu_list`.  

```{r, VennBasePlot}
# Defining the list of data to compare
# if you want less just remove a letter
otu_list <- list( A = tropical.names,
                  B = subtropical.names,
                  C = temperate.names,
                  D = subpolar.names,
                  E = polar.names
)

# Base plot 
venn.v9 <- ggVennDiagram(otu_list, 
                         edge_size = 1, 
                         label_alpha = 0, 
                         label = "count", 
                         label_size = 3.5, 
                         set_size = 4,
                         category.names = c("Tropical","Sub-tropical","Temperate","Sub-polar", "Polar")) # naming each element
```

Building on the previous code block, this one further customizes the Venn diagram using ggplot elements. It adjusts the fill color gradient, line colors, and legend text properties to improve the visual presentation of the Venn diagram. The resulting plot, `venn.v9`, displays the intersection and differences in taxa between ecoregions, with color gradients indicating the count of shared taxa.
  
1. `venn.v9 +`: This part of the code specifies that we are building upon the `venn.v9` plot generated in the previous code block (`VennBasePlot`).  
2. `scale_fill_gradientn(...)`: This line of code adjusts the fill color scale of the Venn diagram. It controls the colors of the different regions in the Venn diagram. The scale_fill_gradientn function allows for a gradient color scale.  
3. `colors = cols.eco(1000)`: Here, the colors are defined using the `cols.venn` function defined in [Colour Schemes](##colour Schemes), which returns a gradient of colors based on `venn_cols` (possibly 1000 different colors). This part sets the color palette for the Venn diagram regions.  
4. `limits = c(0, 1000)`: This sets the lower and upper limits of the color scale. It means that the lowest count (0) will be assigned the first color in the palette, and the highest count (1000) will be assigned the last color in the palette.  
5. `breaks = c(0, 200, 400, 600, 800, 1000)`: Breaks determine the values at which the colors change in the gradient. This code specifies that color transitions should occur at counts of 0, 200, 400, 600, 800, and 1000.  
6. `scale_color_manual(...)`: This line of code customizes the color of the lines outlining the Venn diagram regions. The scale_color_manual function is used to manually set the colors.  
  + `values = vennLine_cols`: It assigns colors to the lines based on the `vennLine_cols` variable defined in [Setup](##Setup), which contains the color scheme for the Venn diagram lines.  
  7.`theme(text = element_text(size = 8))`: This line sets the text properties of the plot's legend. It changes the text size for the legend items to 8 points. This ensures that the legend text is legible and appropriately sized in the final Venn diagram.

```{r, VennPlot}
# Adjusting with ggPlot elements
venn.v9 + scale_fill_gradientn(colors = cols.venn(1000),
                               limits = c(0, 1000), 
                               breaks = c(0, 200, 400, 600, 800, 1000)) + # defining colours, limits and breaks for scale
  scale_color_manual(values = vennLine_cols) + # Changing line colours
  theme(text = element_text(size = 8)) # Set legend text properties
```
####{-}
  
***  
  
### Composition Plots {.tabset .tabset-fade} 
__Data Preparation__    
We are going to create multiple composition plots, one to capture high level EMC trends. Then two too look at the diatom and dinoflagellate changes from tropics to the poles. These will be pie charts that will then be added to a map created in Q-Gis.  
  
This initial code block gets the data sorted for the base of all the composition plots to follow. The `EMC` object will be used for analysis of the whole community, diatoms and dinoflagellates.    
1. The code begins by merging sample data `(waterSamples_filtered)` by the "siteID" column and filtering taxa with a total count greater than zero, resulting in a new dataset `EMC`.  
2. The code further filters the dataset to include only taxa within the `emc.classes`.  
3. The `emc.df `is created by converting the taxonomy data within `EMC` to a data frame.  
4. The `emc.clean` data frame is derived from `emc.df`, and it aims to replace any NA values in the taxonomy data with empty strings and ensure all columns are of character type.  
5. A loop is used to go through each row of the `emc.clean` data frame and make taxonomic assignments to the "kingdom," "phylum," "class," etc., for missing taxonomic levels.  
6. The column names of the `emc.clean` data frame are assigned meaningful names like "Domain," "Supergroup," "Division," etc., representing taxonomic levels.  

```{r CompData}
# Merge by SiteID
EMC <- merge_samples(waterSamples_filtered, "siteID")
EMC <- filter_taxa(EMC, function(x) sum(x) > 0, TRUE)

# Define the specific site order
site_order <- c("T1", "T2", "T3", "N4", "N5", "N6", "N1", "N2", "N3", "C1", "C2", "C3", "P7", "P8", "P9", "P10", "P11", "P5", "P6")

# Filter to EM Taxa
EMC <- subset_taxa(EMC, R5 %in% emc.classes)
# Convert to data frame 
emc.df <- data.frame(tax_table(EMC))
# removes all `NA's` in taxonomy.
emc.clean <- data.frame(tax_table(EMC))
tax_table(EMC) <- as.matrix(emc.clean)

emc.clean <- update_taxa_na(emc.clean)
colnames(emc.clean) <- taxo.divisions
tax_table(EMC) <- as.matrix(emc.clean)
```

Here we are getting the percentages of our microalgae functional groups for each site so that we can give specific values in the manuscript.

```{r composition_proportions}

#library(phyloseq)
#library(tidyverse)

# Use psmelt to obtain a long-format data.frame
phy <- EMC %>% tax_glom(taxrank = "Class") %>% transform_sample_counts(function(x) {x/sum(x)}) %>% psmelt()

#RUN FUNCTION - previously definedwithin this document in the Setup/Define Functions section
#Tropical
T1_perc <- calculate_grouped_percentages(phy, "T1", class_groupings) %>% mutate(ecoregion = "tropical")
T2_perc <- calculate_grouped_percentages(phy, "T2", class_groupings) %>% mutate(ecoregion = "tropical")
T3_perc <- calculate_grouped_percentages(phy, "T3", class_groupings) %>% mutate(ecoregion = "tropical")

#Sub-tropical
N4_perc <- calculate_grouped_percentages(phy, "N4", class_groupings) %>% mutate(ecoregion = "sub.tropical")
N5_perc <- calculate_grouped_percentages(phy, "N5", class_groupings) %>% mutate(ecoregion = "sub.tropical")
N6_perc <- calculate_grouped_percentages(phy, "N6", class_groupings) %>% mutate(ecoregion = "sub.tropical")

# Temperate
N1_perc <- calculate_grouped_percentages(phy, "N1", class_groupings) %>% mutate(ecoregion = "temperate")
N2_perc <- calculate_grouped_percentages(phy, "N2", class_groupings) %>% mutate(ecoregion = "temperate")
N3_perc <- calculate_grouped_percentages(phy, "N3", class_groupings) %>% mutate(ecoregion = "temperate")

#Sub-polar
C1_perc <- calculate_grouped_percentages(phy, "C1", class_groupings) %>% mutate(ecoregion = "sub.polar")
C2_perc <- calculate_grouped_percentages(phy, "C2", class_groupings) %>% mutate(ecoregion = "sub.polar")
C3_perc <- calculate_grouped_percentages(phy, "C3", class_groupings) %>% mutate(ecoregion = "sub.polar")

#Polar
P5_perc <- calculate_grouped_percentages(phy, "P5", class_groupings) %>% mutate(ecoregion = "polar")
P6_perc <- calculate_grouped_percentages(phy, "P6", class_groupings) %>% mutate(ecoregion = "polar")
P7_perc <- calculate_grouped_percentages(phy, "P7", class_groupings) %>% mutate(ecoregion = "polar")
P8_perc <- calculate_grouped_percentages(phy, "P8", class_groupings) %>% mutate(ecoregion = "polar")
P9_perc <- calculate_grouped_percentages(phy, "P9", class_groupings) %>% mutate(ecoregion = "polar")
P10_perc <- calculate_grouped_percentages(phy, "P10", class_groupings) %>% mutate(ecoregion = "polar")
P11_perc <- calculate_grouped_percentages(phy, "P11", class_groupings) %>% mutate(ecoregion = "polar")

compPerc_site_df <- bind_rows(T1_perc, T2_perc, T3_perc, N4_perc, N5_perc, N6_perc, N1_perc, N2_perc, N3_perc, C1_perc, C2_perc, C3_perc, P5_perc, P6_perc, P7_perc, P8_perc, P9_perc, P10_perc, P11_perc)

```
***  
#### EMC
__Eukaryotic Microalgae community (EMC)__  
Here we create plots showing relative abundance of the high-level taxonomic groups across all sampled sited from the tropics to the poles. The taxonomic groups include: dinoflagellates, pennate diatoms, radial centric diatoms, polar centric diatoms, chlorophytes, haptophytes and 'other microalgae.'  
In this section, a specific order for site samples (`site_order`) is defined.

```{r, CompSiteOrder}
# Creates new object `EMC_class` that combines the taxa in `EMC` based on their Class level division.
EMC_class = tax_glom(EMC, "Class")

# calculates the percentages of each class
EMC_class_perc = transform_sample_counts(EMC_class, function(OTU) OTU/sum(OTU)*100)


# can change threshold - (> 1) currently at 1 % can go to zero if less abundance
EMC_class_perc_filtered = filter_taxa(EMC_class_perc, function(x) mean(x) > 0, TRUE)
EMC_class_perc_filtered_df <- psmelt(EMC_class_perc_filtered)


  # Replace with your desired site order
```

Here `taxonomy_breaks` variable is defined as the reverse order of `emc.classes`, which represents taxonomic classes. The code checks for and removes any duplicate values in `taxonomy_breaks`. The "Sample" and "Class" columns in the `EMC_class_perc_filtered_df` data frame are converted to factors with specific order levels based on `site_order` and `taxonomy_breaks`.

```{r, CompTaxaBreaks}
taxonomy_breaks <- rev(emc.classes)
# Check for duplicate values in taxonomy_breaks
duplicates <- taxonomy_breaks[duplicated(taxonomy_breaks)]


# If duplicates are found, remove or adjust them
if (length(duplicates) > 0) {
  taxonomy_breaks <- unique(taxonomy_breaks)  # Remove duplicates
  # Or, adjust the taxonomy_breaks as needed
}

# Convert the Sample column to a factor with the desired order
EMC_class_perc_filtered_df$Sample <- factor(EMC_class_perc_filtered_df$Sample, levels = site_order)
EMC_class_perc_filtered_df$Class <- factor(EMC_class_perc_filtered_df$Class, levels = taxonomy_breaks)

```

In this section, a new column "Ecoregion" is created in the `EMC_class_perc_filtered_df` data frame based on site assignments to different ecoregions (`tropical_sites`, `subtropical_sites`, etc.).

```{r, CompEcoregion}
# Create a new column "Ecoregion" based on site assignments
EMC_class_perc_filtered_df$Ecoregion <- ifelse(EMC_class_perc_filtered_df$Sample %in% tropical_sites, ecoregion_categories[1],
                                                         ifelse(EMC_class_perc_filtered_df$Sample %in% subtropical_sites, ecoregion_categories[2],
                                                                ifelse(EMC_class_perc_filtered_df$Sample %in% temperate_sites, ecoregion_categories[3],
                                                                       ifelse(EMC_class_perc_filtered_df$Sample %in% subpolar_sites, ecoregion_categories[4],
                                                                              ifelse(EMC_class_perc_filtered_df$Sample %in% polar_sites, ecoregion_categories[5], NA)))))
```

The following code defines the plot named `EMC_Comp.v9` using the `ggplot2` library. The purpose of this plot is to visualize the abundance of different taxa classes across various site samples.  
1. `ggplot(EMC_class_perc_filtered_df, aes(x = Sample, y = Abundance, fill = Class))` specifies the dataset `(EMC_class_perc_filtered_df)` and mapping aesthetics for the x-axis (Sample), y-axis (Abundance), and the fill color of the bars based on taxonomic "Class."  
2. `geom_bar(stat = "identity")` creates a bar plot where the height of each bar represents the "Abundance" of a specific taxonomic "Class" for each "Sample." The `stat = "identity"` ensures that the data values are used as-is for bar heights.  
3. `scale_fill_manual(name = "Taxonomy", values = emc_cols, breaks = taxonomy_breaks)` customizes the fill color scale. It assigns the name "Taxonomy" to the legend. The values parameter specifies the colors to be used from the `emc_cols` palette, and breaks sets the order of legend entries based on the taxonomy hierarchy.  
4. Aesthetic customizations include defining axis labels, setting the angle, justification, and vertical adjustment of x-axis text, removing the legend title, adjusting text size and color for various plot elements (axes, title, legend, etc.), and removing background elements like grid lines and panel backgrounds.  
5. `guides(fill = guide_legend(override.aes = list(size=1), ncol=2))` modifies the legend by specifying the legend size and number of columns. The `override.aes` option ensures that the size of legend elements is controlled.  
6. `facet_grid(. ~factor(Ecoregion, levels = c("Tropical", "Sub-tropical", etc)),scales = ...` creates facets for different ecoregions. Each ecoregion is displayed in a separate plot, and the x-axis scales are adjusted accordingly. 
  
Additional theme adjustments are made to improve the appearance of the plot, such as removing background elements and placing facet labels at the bottom.

```{r emcCompPlot}
# Plot
EMC_Comp.v9 <- ggplot(EMC_class_perc_filtered_df, aes(x = Sample, y = Abundance, fill = Class)) + 
  geom_bar(stat = "identity") + 
  scale_fill_manual(name = "Taxonomy", values = emc_cols, breaks = taxonomy_breaks) + 
  theme_bw() + 
  ylab("Proportion OTUs") + 
  xlab("site") + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust=0.4)) + 
  theme(legend.title=element_blank()) + 
  theme(legend.text=element_text(size=8, color="black")) + 
  theme(plot.title=element_text(size=10, color="black")) + 
  theme(axis.text.y= element_text(size=8, color="black")) +
  theme(axis.title.y= element_text(size=8, color="black")) +
  theme(axis.text.x= element_text()) +
  theme(panel.background = element_rect(fill="transparent"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        plot.background = element_rect(fill="transparent", colour=NA),
        legend.background = element_rect(fill="transparent"),
        legend.key = element_rect(fill = NA)) + 
  guides(fill = guide_legend(override.aes = list(size=1), ncol=2)) +
  #facet_grid(. ~factor(Ecoregion, levels = c( "Tropical", "Sub-tropical", "Temperate", "Sub-polar", "Polar")), scales = "free_y", space = "free_y", labeller = labeller(Ecoregion = label_both)) +
  theme(strip.background = element_blank(),  # Remove background of facet labels
        strip.placement = "outside")  # Position facet labels at the bottom

EMC_Comp.v9
  
```

#### Diatoms  
__Diatom community__  
Here we create plots showing relative abundance of major diatom taxonomic divisions across all sampled sited from the tropics to the poles.

```{r diaSetup}
# Diatom Classes
dia.tax_breaks <- c("Bacillariophyceae", "Coscinodiscophyceae", "Mediophyceae")

# Subset data to include algae
diatoms <- subset_taxa(EMC, Class %in% dia.tax_breaks)

# Check for duplicate values in dia.tax_breaks
duplicates <- dia.tax_breaks[duplicated(dia.tax_breaks)]

# If duplicates are found, remove or adjust them
if (length(duplicates) > 0) {
  dia.tax_breaks <- unique(dia.tax_breaks)  # Remove duplicates
  # Or, adjust the dia.tax_breaks as needed
}

# create dataframe
dia.taxa.df <- data.frame(tax_table(diatoms))

# removes all `NA's` in taxonomy.
dia.tax.clean <- data.frame(tax_table(diatoms))
```

```{r diaTaxLvl}
# Creates new object `emc_class` that combines the taxa in `emc` based on their Class level division.
dia_order = tax_glom(diatoms, "Order")
#dia_order = tax_glom(diatoms, "Class")
```

```{r diaTax_check}
dia.pen_taxa_df <- dia.tax.clean[dia.tax.clean$Class == "Bacillariophyceae",] # change between classes you want to check: "Coscinodiscophyceae", "Mediophyceae"
dia.order_counts <- table(dia.pen_taxa_df$Order)
dia.order_names <- names(dia.order_counts)

#print(dia.order_names)
```

```{r diaTaxa_define}
dia.order.breaks <-c("Bacillariales", "Cymbellales", "Fragilariales", "Licmophorales", "Naviculales", "Plagiogrammales", "Rhabdonematales", "Rhaphoneidales", "Rhopalodiales", "Surirellales", "Unclassified_Class_Bacillariophyceae", #Pennate
                     "Corethrales", "Coscinodiscales", "Melosirales", "Paraliales", "Rhizosoleniales", "Stellarimales", "Triceratiales", "Unclassified_Class_Coscinodiscophyceae", 
                     "Anaulales", "Ardissoneales", "Biddulphiales", "Chaetocerotales", "Cymatosirales", "Eupodiscales", "Hemiaulales", "Lithodesmiales", "Probosciales", "Thalassiosirales", "Unclassified_Class_Mediophyceae" #polar.cent
)

```

```{r diaEcoregion}
# calculates the percentages of each class
dia_order_perc = transform_sample_counts(dia_order, function(OTU) OTU/sum(OTU)*100)

# can change threshold - (> 1) currently at 1 % can go to zero if less abundance
dia_order_perc_filtered = filter_taxa(dia_order_perc, function(x) mean(x) > .01, TRUE)
dia_order_perc_filtered_df <- psmelt(dia_order_perc_filtered)

# Convert the Sample column to a factor with the desired order
dia_order_perc_filtered_df$Sample <- factor(dia_order_perc_filtered_df$Sample, levels = site_order)
dia_order_perc_filtered_df$Order <- factor(dia_order_perc_filtered_df$Order, levels = dia.order.breaks)
#dia_order_perc_filtered_df$Class <- factor(dia_order_perc_filtered_df$Class, levels = dia.tax_breaks)

# Create a new column "Ecoregion" based on site assignments
dia_order_perc_filtered_df$Ecoregion <- ifelse(dia_order_perc_filtered_df$Sample %in% tropical_sites, ecoregion_categories[1],
                                                  ifelse(dia_order_perc_filtered_df$Sample %in% subtropical_sites, ecoregion_categories[2],
                                                         ifelse(dia_order_perc_filtered_df$Sample %in% temperate_sites, ecoregion_categories[3],
                                                                ifelse(dia_order_perc_filtered_df$Sample %in% subpolar_sites, ecoregion_categories[4],
                                                                       ifelse(dia_order_perc_filtered_df$Sample %in% polar_sites, ecoregion_categories[5], NA)))))

# Define colour scheme
dia_cols <- c("#f16a58","#fcdeb4", "#fbb768")
col.dia <- colorRampPalette(dia_cols)
```

```{r diaBarPlot}
# Plot
dia.comp.plot <- ggplot(dia_order_perc_filtered_df, aes(x = Abundance, y = Sample, fill = Order)) + 
  geom_bar(stat = "identity") + 
  scale_fill_manual(name = "Taxonomy", values = dia.order.cols, breaks = dia.order.breaks) + 
  theme_bw() + 
  ylab("Site-Depth") + 
  xlab("Proportion ASVs") + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust=0.4)) + 
  theme(legend.title=element_blank()) + 
  theme(legend.text=element_text(size=8, color="black")) + 
  theme(plot.title=element_text(size=10, color="black")) + 
  theme(axis.text.y= element_text(size=8, color="black")) +
  theme(axis.title.y= element_text(size=8, color="black")) +
  theme(axis.text.x= element_text()) +
  theme(panel.background = element_rect(fill="transparent"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        plot.background = element_rect(fill="transparent", colour=NA),
        legend.background = element_rect(fill="transparent"),
        legend.key = element_rect(fill = NA)) + 
  
  guides(fill = guide_legend(override.aes = list(size=1), ncol=2)) +
  
  facet_grid(. ~factor(Ecoregion, levels = c("Tropical", "Sub-tropical", "Temperate", "Sub-polar", "Polar")) ~., scales = "free_y", space = "free_y", labeller = labeller(Ecoregion = label_both)) +
  theme(strip.background = element_blank(),  # Remove background of facet labels
        strip.placement = "outside")  # Position facet labels at the bottom

dia.comp.plot
```

```{r diaPie}
dia.pie <- ggplot(dia_order_perc_filtered_df, aes(x = "", y = Abundance, fill = Class)) +
  geom_bar(stat = "identity", width = 1) +
  coord_polar("y", start = 0) +  # Convert to polar coordinate
  theme_void() +  # Remove axes and gridlines
  facet_wrap(~ Sample) +  # Create facets for each site
  scale_fill_manual(name = "Taxonomy", values = dia_cols) +  # Assign specific colors to classes
  theme(legend.title = element_blank()) +  # Remove legend title
  theme(legend.text = element_text(size = 8, color = "black")) +  # Set legend text properties
  theme(plot.title = element_text(size = 10, color = "black"))  # Set plot title properties

dia.pie
```


#### Dinoflagellates  
__Dinoflagellate community__  
Here we create plots showing relative abundance of major dinoflagellate taxonomic divisions across all sampled sited from the tropics to the poles. 
First we sub-set the EMC data to only dinoflagellates.  

```{r dinoSubset}
# Subset data to include algae
dino <- subset_taxa(EMC, Class == "Dinophyceae") 

# create dataframe
dino.taxa.df <- data.frame(tax_table(dino))

# removes all `NA's` in taxonomy.
dino.tax.clean <- data.frame(tax_table(dino))
tax_table(dino) <- as.matrix(dino.tax.clean)

# Creates new object `emc_class` that combines the taxa in `emc` based on their Class level division.
dino_order = tax_glom(dino, "Order")

# calculates the percentages of each class
dino_order_perc = transform_sample_counts(dino_order, function(OTU) OTU/sum(OTU)*100)

# can change threshold - (> 1) currently at 1 % can go to zero if less abundance
dino_order_perc_filtered = filter_taxa(dino_order_perc, function(x) mean(x) > .01, TRUE)
dino_order_perc_filtered_df <- psmelt(dino_order_perc_filtered)

# Convert the Sample column to a factor with the desired order
dino_order_perc_filtered_df$Sample <- factor(dino_order_perc_filtered_df$Sample, levels = site_order)
#dino_order_perc_filtered_df$Order <- factor(dino_order_perc_filtered_df$Order, levels = dia.taxonomy_breaks)
# Define ecoregion categories

# Create a new column "Ecoregion" based on site assignments
dino_order_perc_filtered_df$Ecoregion <- ifelse(dino_order_perc_filtered_df$Sample %in% tropical_sites, ecoregion_categories[1],
                                                  ifelse(dino_order_perc_filtered_df$Sample %in% subtropical_sites, ecoregion_categories[2],
                                                         ifelse(dino_order_perc_filtered_df$Sample %in% temperate_sites, ecoregion_categories[3],
                                                                ifelse(dino_order_perc_filtered_df$Sample %in% subpolar_sites, ecoregion_categories[4],
                                                                       ifelse(dino_order_perc_filtered_df$Sample %in% polar_sites, ecoregion_categories[5], NA)))))

```
  
Here we use the sub-set dinoflagellate data to create stacked bar charts with the relative abundance of taxonomic groups.
  
```{r dinoBarPlot}
# Plot
dino.v9 <- ggplot(dino_order_perc_filtered_df, aes(x = Abundance, y = Sample, fill = Order)) + 
  geom_bar(stat = "identity") + 
  scale_fill_manual(name = "Taxonomy", values = dino_cols) + 
  theme_bw() + 
  ylab("Site-Depth") + 
  xlab("Proportion ASVs") + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust=0.4)) + 
  theme(legend.title=element_blank()) + 
  theme(legend.text=element_text(size=8, color="black")) + 
  theme(plot.title=element_text(size=10, color="black")) + 
  theme(axis.text.y= element_text(size=8, color="black")) +
  theme(axis.title.y= element_text(size=8, color="black")) +
  theme(axis.text.x= element_text()) +
  theme(panel.background = element_rect(fill="transparent"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        plot.background = element_rect(fill="transparent", colour=NA),
        legend.background = element_rect(fill="transparent"),
        legend.key = element_rect(fill = NA)) + 
  
  guides(fill = guide_legend(override.aes = list(size=1), ncol=1)) +
  
  facet_grid(. ~factor(Ecoregion, levels = c("Tropical", "Sub-tropical", "Temperate", "Sub-polar", "Polar")) ~., scales = "free_y", space = "free_y", labeller = labeller(Ecoregion = label_both)) +
  theme(strip.background = element_blank(),  # Remove background of facet labels
        strip.placement = "outside")  # Position facet labels at the bottom


dino.v9 

```
  
Here we use the same sub-set dinoflagellate data to create pie charts with the relative abundance of taxonomic groups. These will be plotted over the site map to highlight the changes down the sampled latitudinal gradient.  
  
```{r dinoPieChart}

compositionplot.pie <- ggplot(dino_order_perc_filtered_df, aes(x = "", y = Abundance, fill = Order)) +
  geom_bar(stat = "identity", width = 1) +
  coord_polar("y", start = 0) +  # Convert to polar coordinate
  theme_void() +  # Remove axes and gridlines
  facet_wrap(~ Sample) +  # Create facets for each site
  scale_fill_manual(name = "Taxonomy", values = dino_cols) +  # Assign specific colors to classes
  theme(legend.title = element_blank()) +  # Remove legend title
  theme(legend.text = element_text(size = 8, color = "black")) +  # Set legend text properties
  theme(plot.title = element_text(size = 10, color = "black"))  # Set plot title properties

compositionplot.pie
```

#### {-}
#### {-}
   
***  

### Dendrograms {.tabset .tabset-fade}  
__Data Preparation__    
Here the goal is to create a series of Dendrograms:  
* One for each ecoregion, Tropical, sub-tropical, temperate, sub-polar and polar. This will show what families occur in each separate ecoregion.  
* A Dendrogram will all the species that occur across all the ecoregions. This will then be styled in Adobe Illustrator, with dots at the exterior to show which ecoregion the families all occur in.  
  
* `dendro_emc <- merge_samples()`: This line merges the data in `waterSamples_filtered` based on the `ecoregion` column and stores the result in `dendro_emc`.  
* `dendro_emc <- subset_taxa()`: Here, it subsets the data in `dendro_emc` based on the condition where the `R5` column's values are present in the `emc.classes` vector, updating `dendro_emc`.  
* `dendro_emc <- filter_taxa()`: This line filters the data in `dendro_emc`, keeping only those rows where the sum of values in each row is greater than 0.  
* We then convert the taxonomic table within `dendro_emc` into a data frame (`dendro_emc.df`) and make a copy of it as `dendro_emc.clean.` It then converts `dendro_emc.clean` to a matrix and assigns it to the taxonomic table of `dendro_emc`. Finally, it updates `dendro_emc.clean` by removing any NAs.  
* Finally we define a vector `taxo.divisions` with new column names for taxonomic divisions. Then, it assigns these column names to `dendro_emc.clean` and updates the taxonomic table of `dendro_emc` using `dendro_emc.clean` as a matrix.

```{r DendroSetup}
# Merge by ecoregion
dendro_emc <- merge_samples(waterSamples_filtered, "ecoregion")
# Subset to R5 level
dendro_emc <- subset_taxa(dendro_emc, R5 %in% emc.classes)
# Clean
dendro_emc <- filter_taxa(dendro_emc, function(x) sum(x) > 0, TRUE)

# Convert to data frame 
dendro_emc.df <- data.frame(tax_table(dendro_emc))
dendro_emc.clean <- data.frame(tax_table(dendro_emc)) 
tax_table(dendro_emc) <- as.matrix(dendro_emc.clean)
dendro_emc.clean <- update_taxa_na(dendro_emc.clean) # run function to remove NAs

# Define new column names
taxo.divisions <- c("Domain", "Supergroup", "Division", "Sub.division", "Class", "Order", "Family", "Genus", "Species")

colnames(dendro_emc.clean) <- taxo.divisions
tax_table(dendro_emc) <- as.matrix(dendro_emc.clean)
```
    
* Next, assign values to `ecoregion`, `type`, and `ecosystem` columns in the sample data associated with `dendro_emc`.  
  
* 'ecoregion' is assigned values: "polar", "sub-tropical", "sub-polar", "temperate", "tropical".  
* 'type' is assigned values: "water", "water", "water", "water", "water".  
* 'ecosystem' is assigned values: "coastal", "coastal", "coastal", "coastal", "coastal".  
* Removes columns from the sample data of dendro_emc: 'sampleID', 'siteID', 'point', 'replicate', and 'location' columns are all removed.
  
``` {r DendroDataSort}
sample_data(dendro_emc)$ecoregion <- c("polar", "sub-tropical", "sub-polar", "temperate", "tropical")
sample_data(dendro_emc)$type <- c("water", "water", "water", "water", "water")
sample_data(dendro_emc)$ecosystem <- c("coastal", "coastal", "coastal", "coastal", "coastal")
sample_data(dendro_emc)$sampleID <- NULL
sample_data(dendro_emc)$siteID <- NULL
sample_data(dendro_emc)$point <- NULL
sample_data(dendro_emc)$replicate <- NULL
sample_data(dendro_emc)$location <- NULL
sample_data(dendro_emc)

```
#### All Ecoregions
__All Ecoregions Dendrogram__  
Now get an initial list of all families that occur across all ecoregions, broken out into taxonomic-functional groups to build the dendrogram.

Run this segment on both the V4 and V9 region data to get complete list detected.

``` {r DendroLists}
#Removing Unclassified families
remove_unclass <- function(data_frame) {
  # Filter out 'unclassified' entries from the 'Family' column
  filtered_data_frame <- data_frame %>%
    filter(!grepl("unclassified", Family, ignore.case = TRUE))
  
  return(filtered_data_frame)
}

#Dinflagellates
#dendro_dino <- subset_taxa(dendro_emc, Class %in% dinoflagellates)
#taxa_dino <- data.frame(tax_table(dendro_dino))
#tally_dino_fam <- taxa_dino %>% group_by(Sub.division, Class, Order, Family) %>% tally()
#tally_dino_fam <- remove_unclass(tally_dino_fam)
#print(tally_dino_fam$Family)

#Diatoms
#dendro_diatom <- subset_taxa(dendro_emc, Class %in% diatoms)
#taxa_diatom <- data.frame(tax_table(dendro_diatom))
#tally_diatom_fam <- taxa_diatom %>% group_by(Sub.division, Class, Order, Family) %>% tally()
#tally_diatom_fam <- remove_unclass(tally_diatom_fam)
#print(tally_diatom_fam$Family)

#Chlorophtes
#dendro_chloro <- subset_taxa(dendro_emc, Class %in% chlorophytes)
#taxa_chloro <- data.frame(tax_table(dendro_chloro))
#tally_chloro_fam <- taxa_chloro %>% group_by(Sub.division, Class, Order, Family) %>% tally()
#tally_chloro_fam <- remove_unclass(tally_chloro_fam)
#print(tally_chloro_fam$Family)

#Haptophtes
#dendro_hapto <- subset_taxa(dendro_emc, Class %in% haptophytes)
#taxa_hapto <- data.frame(tax_table(dendro_hapto))
#tally_hapto_fam <- taxa_hapto %>% group_by(Sub.division, Class, Order, Family) %>% tally()
#tally_hapto_fam <- remove_unclass(tally_hapto_fam)
#print(tally_hapto_fam$Family)

#Other
#dendro_other <- subset_taxa(dendro_emc, Class %in% other)
#taxa_other <- data.frame(tax_table(dendro_other))
#tally_other_fam <- taxa_other %>% group_by(Sub.division, Class, Order, Family) %>% tally()
#tally_other_fam <- remove_unclass(tally_other_fam)
#print(tally_other_fam$Family)
```
  
***  
  
___Define Dendrogram structure___  
Here the structure of the Dendrogram is defined, based off the lists created in the previous code block.  

```{r dendroStructure}
dendro_text_all <- "(((Dinophyceae_XX), (Amphisoleniaceae, Dinophysiaceae, Oxyphysiaceae), (Ceratiaceae, Gonyaulacaceae, Lingulodiniaceae, Ostreopsidaceae, Protoceratiaceae, Pyrocystaceae), (Ceratoperidiniaceae, Chytriodiniaceae, Gymnodiniaceae, Kareniaceae, Warnowiaceae), (Amphidiniopsidaceae, Amphidomataceae, Blastodiniaceae, Diplopsalidaceae, Heterocapsaceae, Kryptoperidiniaceae, Peridiniales_X, Peridiniopsidaceae, Protoperidiniaceae, Thoracosphaeraceae), (Prorocentraceae, Suessiaceae, Suessiales_X, Symbiodiniaceae), (Torodiniaceae)), (((Bacillariaceae), (Cymbellaceae, Gomphonemataceae), (Fragilariaceae), (Licmophoraceae),(Naviculaceae, Pleurosigmataceae, Sellaphoraceae), (Plagiogrammaceae), (Grammatophoraceae, Tabellariaceae), (Asterionellopsidaceae), (Rhopalodiaceae), (Surirellaceae)),((Corethraceae), (Coscinodiscaceae, Heliopeltaceae, Hemidiscaceae), (Hyalodiscaceae, Melosiraceae), (Paraliaceae), (Rhizosoleniaceae), (Stellarimaceae), (Triceratiaceae)),((Anaulaceae), (Ardissoneaceae), (Biddulphiaceae), (Chaetocerotaceae, Leptocylindraceae), (Cymatosiraceae), (Parodontellaceae), (Hemiaulaceae), (Lithodesmiaceae), (Probosciaceae),(Lauderiaceae), (Skeletonemaceae, Stephanodiscaceae, Thalassiosiraceae)),(((Euglenida_XX, Keelungiidae), (Euglenaceae, Eutreptiidae)), (Parmales_env_2, Parmales_env_3, Triparmaceae), ((Chrysophyceae_Clade-EC2H_X, Chrysophyceae_Clade-EC2I_X), (Ochromonadaceae), (Paraphysomonadaceae, Paraphysomonadales_Clade_EC1Ga)), (Dictyochales, Florenciellales, Pedinellales, Rhizochromulinales), ((Pelagomonadaceae, Pelagomonadales_Clade_A,  Pelagomonadales_Clade_B), (Chrysocystaceae, Sarcinochrysidaceae)), (Pinguiochrysidaceae), (Raphidophyceae_XX))), ((Coccolithaceae), (Pavlovaceae), ((Noelaerhabdaceae), (Phaeocystaceae), (Chrysochromulinaceae, Prymnesiaceae, Prymnesiales_X, Prymnesiophyceae_Clade_B4, Prymnesiophyceae_Clade_E_X, Prymnesiophyceae_Clade_F_X), (Braarudosphaeraceae), (Syracosphaerales_X)), (Pavlomulinaceae)), ((Chlorodendraceae), (Chaetopeltidales_X, Chlamydomonadales_X, Sphaeropleales_X), (Chloropicaceae), ((Crustomastigaceae, Dolichomastigaceae), (Bathycoccaceae, Mamiellaceae)), (Nephroselmidales_X), (Marsupiomonadaceae), ((Pycnococcaceae), (Pterospermaceae, Pyramimonadaceae, Pyramimonadales_X)), ((Chlorellales_X), (Microthamniales_X), (Trebouxiophyceae_XX), (Watanabea-Clade_X))));"
```
  
***  
  
___Plot Dendrogram___   
This next code snippet reads a phylogenetic tree from text, sets a specific text size, and then plots the dendrogram with a 'fan' layout, adjusting the text size of labels according to the defined text_size.  
  
* `dendro <- ape::read.tree(text = dendro_text_all)`: Reads a phylogenetic tree from a text string (`dendro_text_all`) using the read.tree function from the `ape` package. The resulting tree is stored in the `dendro` variable.  
* `text_size <- 0.5`: Sets the variable `text_size` to a value of 0.5, specifying the size for text labels in the dendrogram.  
* `plot(dendro, type = "fan", cex = text_size)`: Plots the dendrogram represented by the `dendro` tree object.  
  * `type = fan` specifies the dendrogram type as a 'fan' layout.  
  * `cex = text_size` sets the text size to the previously defined `text_size` value (0.5) for the dendrogram labels.

```{r dendroPlot}
# Read the tree
dendro <- ape::read.tree(text = dendro_text_all)

# Specify text size
text_size <- 0.5

# Plot the dendrogram with customized settings
plot(dendro, type = "fan", cex = text_size)

```
  
***  
  
#### Single ecoregion
__Single ecoregion Dendrogram__  
Here the previous step is repeated for an individual ecoregion to identify what families occur where. The following code is for the Tropical ecoregion, change `ecoregion ==''` to the target ecoregion. Cycle through all.  
```{r DendroEcoregion_subset}
#Subset to one ecoregion samples only - change this as needed.
dendro_emc.ecoregion <- subset_samples(dendro_emc, ecoregion == "tropical")
dendro_emc.ecoregion <- filter_taxa(dendro_emc.ecoregion, function(x) sum(x) > 0, TRUE)
sample_sums(dendro_emc.ecoregion)
```  
  ***  
    
__Define structure__  
This code is commented out, as it is just setting up the structure of the dendrogram.
```{r DendroEcoregion_structure}
#Dinflagellates
#trop.dendro_dino <- subset_taxa(dendro_emc.ecoregion, Class %in% dinoflagellates)
#trop.dendro_dino <- filter_taxa(trop.dendro_dino, function(x) sum(x) > 0, TRUE)
#trop.taxa_dino <- data.frame(tax_table(trop.dendro_dino))
#trop.tally_dino_fam <- trop.taxa_dino %>% group_by(Sub.division, Class, Order, Family, Genus, Species) %>% tally()
#trop.tally_dino_fam <- remove_unclass(trop.tally_dino_fam)
#print(trop.tally_dino_fam$Family)

#Diatoms
#trop.dendro_diatom <- subset_taxa(dendro_emc.trop, Class %in% diatoms)
#trop.dendro_diatom <- filter_taxa(trop.dendro_diatom, function(x) sum(x) > 0, TRUE)
#trop.taxa_diatom <- data.frame(tax_table(trop.dendro_diatom))
#trop.tally_diatom_fam <- trop.taxa_diatom %>% group_by(Sub.division, Class, Order, Family) %>% tally()
#trop.tally_diatom_fam <- remove_unclass(trop.tally_diatom_fam)
#print(trop.tally_diatom_fam$Family)

#Chlorophtes
#trop.dendro_chloro <- subset_taxa(dendro_emc.trop, Class %in% chlorophytes)
#trop.dendro_chloro <- filter_taxa(trop.dendro_chloro, function(x) sum(x) > 0, TRUE)
#trop.taxa_chloro <- data.frame(tax_table(trop.dendro_chloro))
#trop.tally_chloro_fam <- trop.taxa_chloro %>% group_by(Sub.division, Class, Order, Family) %>% tally()
#trop.tally_chloro_fam <- remove_unclass(trop.tally_chloro_fam)
#print(trop.tally_chloro_fam$Family)

#Haptophtes
#trop.dendro_hapto <- subset_taxa(dendro_emc.trop, Class %in% haptophytes)
#trop.dendro_hapto <- filter_taxa(trop.dendro_hapto, function(x) sum(x) > 0, TRUE)
#trop.taxa_hapto <- data.frame(tax_table(trop.dendro_hapto))
#trop.tally_hapto_fam <- trop.taxa_hapto %>% group_by(Sub.division, Class, Order, Family) %>% tally()
#trop.tally_hapto_fam <- remove_unclass(trop.tally_hapto_fam)
#print(trop.tally_hapto_fam$Family)

#Other
#trop.dendro_other <- subset_taxa(dendro_emc.trop, Class %in% other)
#trop.taxa_other <- data.frame(tax_table(trop.dendro_other))
#trop.tally_other_fam <- trop.taxa_other %>% group_by(Sub.division, Class, Order, Family) %>% tally()
#trop.tally_other_fam <- remove_unclass(trop.tally_other_fam)
#print(trop.tally_other_fam$Family)

```  
  ***  
    
__Plot Dengrogram__  
```{r DendroEcoregion_plot}

dendro_text_ecoregion <- "(((Dinophysiaceae, Oxyphysiaceae), (Ceratiaceae, Gonyaulacaceae, Lingulodiniaceae, Protoceratiaceae, Pyrocystaceae), (Gymnodiniaceae, Kareniaceae), (Amphidiniopsidaceae, Amphidomataceae, Blastodiniaceae, Kryptoperidiniaceae, Peridiniales_X, Protoperidiniaceae, Thoracosphaeraceae), (Prorocentraceae, Suessiaceae, Symbiodiniaceae), (Torodiniaceae)), (((Bacillariaceae), (Cymbellaceae), (Fragilariaceae), (Licmophoraceae),(Naviculaceae), (Plagiogrammaceae), (Grammatophoraceae),(Rhopalodiaceae), (Surirellaceae)),((Hemidiscaceae), (Hyalodiscaceae, Melosiraceae), (Stellarimaceae), (Triceratiaceae)), ((Ardissoneaceae), (Biddulphiaceae), (Chaetocerotaceae, (Cymatosiraceae), (Hemiaulaceae), (Lithodesmiaceae), (Probosciaceae), Thalassiosiraceae)),(((Euglenida_XX, Keelungiidae), (Euglenaceae, Eutreptiidae)), (Parmales_env_2, Parmales_env_3, Triparmaceae), ((Chrysophyceae_Clade-EC2H_X, Chrysophyceae_Clade-EC2I_X), (Ochromonadaceae), (Paraphysomonadaceae, Paraphysomonadales_Clade_EC1Ga)), (Dictyochales, Florenciellales, Pedinellales, Rhizochromulinales), ((Pelagomonadaceae, Pelagomonadales_Clade_A,  Pelagomonadales_Clade_B), (Chrysocystaceae, Sarcinochrysidaceae)), (Pinguiochrysidaceae), (Raphidophyceae_XX))), ((Chlorodendraceae), (Chaetopeltidales_X, Chlamydomonadales_X, Sphaeropleales_X), (Chloropicaceae), ((Crustomastigaceae, Dolichomastigaceae), (Bathycoccaceae, Mamiellaceae)), (Nephroselmidales_X), (Marsupiomonadaceae), ((Pycnococcaceae), (Pterospermaceae, Pyramimonadaceae, Pyramimonadales_X)), ((Microthamniales_X), (Watanabea-Clade_X))), ((Pavlovaceae), ((Noelaerhabdaceae), (Phaeocystaceae), (Chrysochromulinaceae, Prymnesiaceae, Prymnesiales_X, Prymnesiophyceae_Clade_B4), (Braarudosphaeraceae)), (Pavlomulinaceae)));"

dendro_emc.ecoregion <- ape::read.tree(text = dendro_text_ecoregion)
# Specify text size
text_size <- 0.5
# Plot the dendrogram with customized settings
plot(dendro, type = "fan", cex = text_size)
```  

####{-}  

***  
